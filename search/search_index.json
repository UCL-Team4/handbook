{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Foreword","text":"<p>Welcome to our Code Handbook! This handbook is here to help us stay aligned as we work together on our project. It\u2019s designed to keep our code style and techniques consistent, so everyone\u2019s work is easy to read, understand, and build on.</p> <p>Inside, you\u2019ll find examples, tips, and guidelines that make it easier for us to code in sync. By following the same patterns and practices, we can avoid confusion, save time, and ensure our project stays organized and maintainable as it grows.</p> <p>Let\u2019s keep this handbook open for updates and ideas from everyone\u2014it\u2019s a tool we\u2019re building together to support our success!</p>"},{"location":"conditionals/","title":"Conditionals","text":""},{"location":"conditionals/#default-values","title":"Default Values","text":"<p>Consider ternary operator '??' instead of nil checks to improve readability. BAD<pre><code>if (name != null)\n{\n    return name;\n}\nelse\n{\n    return \"John Doe\";\n}\n</code></pre> GOOD<pre><code>return name ?? \"John Doe\";\n</code></pre></p>"},{"location":"conditionals/#dont-write-if-true-return-true","title":"Don't Write \"if true return true\"","text":"<p>When returning or setting a variable to the value of the conditional statement itself, don't use an else block. BAD<pre><code>if (name == \"mark\" || name == \"stacy\")\n{\n    return true;\n}\nelse\n{\n    return false;\n}\n</code></pre> GOOD<pre><code>return name == \"mark\" || name == \"stacy\";\n</code></pre></p>"},{"location":"conditionals/#prefer-positive-boolean-expressions","title":"Prefer positive boolean expressions","text":"<p>This ensures that the code remains easy to read. BAD<pre><code>if (!isHappy)\n{\n    return \"sad\";\n}\nelse\n{\n    return \"happy\";\n}\n</code></pre> GOOD<pre><code>if (isHappy)\n{\n    return \"happy\";\n}\nelse\n{\n    return \"sad\";\n}\n</code></pre></p>"},{"location":"github/","title":"Github","text":"<p>This page goes over the best practices on how we use github to manage our project and workflow.</p>"},{"location":"github/#semantic-commit-messages","title":"Semantic Commit Messages","text":"<p>We use semantic commit messages to keep our commit history clean, organized, and easy to understand. This helps us quickly identify what each commit does, track down issues, and generate meaningful release notes.</p>"},{"location":"github/#commit-message-format","title":"Commit Message Format","text":"<p>A semantic commit message follows this format: <pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;description&gt;\n</code></pre></p>"},{"location":"github/#type-the-type-of-change-being-made-eg-feat-fix-docs-style-refactor-test-chore","title":"Type: The type of change being made (e.g., feat, fix, docs, style, refactor, test, chore).","text":""},{"location":"github/#scope-optional-the-scope-of-the-change-eg-variable-name-file-module-feature","title":"Scope (optional): The scope of the change (e.g., variable name, file, module, feature).","text":""},{"location":"github/#description-a-short-description-of-the-change","title":"Description: A short description of the change.","text":""},{"location":"github/#examples","title":"Examples","text":"<p>Here are some examples of semantic commit messages: <pre><code>feat(cart): add functionality to apply discount codes\nfix(login): resolve session timeout issue on login page\ndocs(readme): update setup instructions for developers\nstyle(product-list): format product cards for mobile view\nrefactor(api): simplify order processing logic for scalability\ntest(user): add unit tests for user registration process\nchore(env): configure dotenv for environment variables\n</code></pre></p>"},{"location":"github/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>When creating a pull request, follow these guidelines to ensure your code is reviewed and merged smoothly.</p>"},{"location":"github/#pull-request-template","title":"Pull Request Template","text":"<p>Use the following template when creating a pull request:</p> <pre><code>## Description\nDescribe the changes made in this pull request. Explain what feature, bug fix, or enhancement was added, and why it was necessary. Provide any context that will help reviewers understand the purpose of the PR.\n\n## Related Issue(s)\nLink any related issues here by using \"Closes #issue-number\". If this PR resolves multiple issues, list each one.\n\n## Type of Change\n- [ ] \ud83c\udd95 New feature (adds functionality to the webshop app)\n- [ ] \ud83d\udc1b Bug fix (resolves an issue in the webshop app)\n- [ ] \ud83d\udd04 Refactor (improves code structure without changing functionality)\n- [ ] \ud83d\udd27 Chore (maintenance task, e.g., updating dependencies)\n\n## Checklist\n- [ ] My code follows the code style and conventions of the project.\n- [ ] I have performed a self-review of my code.\n- [ ] I have commented my code, particularly in hard-to-understand areas.\n- [ ] I have written unit tests for the changes, if necessary.\n- [ ] All tests pass on my local machine.\n- [ ] This PR is ready for review.\n\n## Additional Notes\nAdd any additional information here. Mention if there are any known issues, limitations, or special considerations for the PR.\n</code></pre>"},{"location":"methods/","title":"Methods","text":""},{"location":"methods/#size-scope","title":"Size &amp; Scope","text":"<ul> <li>Functions should only do one thing and should be small. If a function is not small, break it up into smaller functions.</li> <li>Avoid mixing high-level code with low-level code in the same function.</li> </ul> BAD<pre><code>// BAD: This function does too much and mixes high- and low-level logic\ndecimal ApplyDiscount(Customer customer, decimal price)\n{\n    // High-level: Validate input\n    if (customer == null || price &lt;= 0)\n    {\n        throw new ArgumentException(\"Invalid customer or price\");\n    }\n\n    // Low-level: Calculate discount\n    decimal discount = customer.IsMember ? price * 0.1m : 0;\n\n    // High-level: Apply discount\n    return price - discount;\n}\n</code></pre> GOOD<pre><code>// GOOD: Each function does one thing, and responsibilities are separated\ndecimal ApplyDiscount(Customer customer, decimal price)\n{\n    ValidateInput(customer, price);\n    decimal discount = CalculateDiscount(customer, price);\n    return price - discount;\n}\n\nvoid ValidateInput(Customer customer, decimal price)\n{\n    if (customer == null || price &lt;= 0)\n    {\n        throw new ArgumentException(\"Invalid customer or price\");\n    }\n}\n\ndecimal CalculateDiscount(Customer customer, decimal price)\n{\n    return customer.IsMember ? price * 0.1m : 0;\n}\n</code></pre>"},{"location":"methods/#naming","title":"Naming","text":"<ul> <li>Local functions should be named in camelCase format to differentiate them from standard library methods.</li> <li>Public or global functions should be named in PascalCase format.</li> <li>Functions should also be named with a leading verb.</li> </ul> <p>BAD<pre><code>void Player() { }\nvoid PlayerDrop() { }\n</code></pre> GOOD<pre><code>void GetPlayerObject() { }\nvoid DropPlayer() { }\n</code></pre></p>"},{"location":"methods/#parameters","title":"Parameters","text":""},{"location":"methods/#limit-number-of-parameters","title":"Limit Number of Parameters","text":"<p>If needing more than 3 or so parameters for a single method, consider grouping the parameters within a class or struct. This enhances readability and makes the method easier to manage.</p> <p>BAD<pre><code>void CreateCharacter(string name, int age, double height, DateTime birthday, string nationality) { }\n</code></pre> // BAD void CreateCharacter(string name, int age, double height, DateTime birthday, string nationality) { }</p> GOOD<pre><code>public class Character\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n    public double Height { get; set; }\n    public DateTime Birthday { get; set; }\n    public string Nationality { get; set; }\n}\n\nvoid CreateCharacter(Character character) { }\n</code></pre>"},{"location":"methods/#optional-parameters","title":"Optional Parameters","text":""},{"location":"methods/#required-parameters-should-come-before-optional-ones","title":"Required parameters should come before optional ones.","text":"<p>BAD<pre><code>void PrintMessage(bool isUrgent = false, string message)\n{\n    Console.WriteLine(isUrgent ? \"URGENT: \" + message : message);\n}\n</code></pre> GOOD<pre><code>void PrintMessage(string message, bool isUrgent = false)\n{\n    Console.WriteLine(isUrgent ? \"URGENT: \" + message : message);\n}\n</code></pre></p>"},{"location":"methods/#use-guard-clauses","title":"Use Guard Clauses","text":""},{"location":"methods/#often-before-doing-the-real-work-of-a-method-certain-pre-conditions-must-be-met","title":"Often, before doing the \"real\" work of a method, certain pre-conditions must be met.","text":"<p>Guard clauses are conditional statements that provide early returns to check these conditions, allowing for early exits and reducing nesting, which improves readability.</p> <p>BAD<pre><code>string GetFullName(string firstName, string lastName)\n{\n    if (!nameHidden &amp;&amp; firstName != null &amp;&amp; lastName != null)\n    {\n        return firstName + \" \" + lastName;\n    }\n    else\n    {\n        return null;\n    }\n}\n</code></pre> GOOD<pre><code>string GetFullName(string firstName, string lastName)\n{\n    if (nameHidden) return null;\n    if (firstName == null || lastName == null) return null;\n    return firstName + \" \" + lastName;\n}\n</code></pre></p>"},{"location":"unittest/","title":"Unit Test","text":""},{"location":"unittest/#red-green-refactor","title":"Red Green Refactor","text":"<p>The Red-Green-Refactor cycle is a way to develop software incrementally and iteratively. It is a core practice of Test-Driven Development (TDD) and is used to ensure that the code is working correctly and efficiently.</p>"},{"location":"unittest/#red-phase-failing-test","title":"Red Phase (Failing Test)","text":"<p>Begin by writing a test for the functionality you plan to implement. At this point, the test should fail since the functionality does not yet exist or isn\u2019t complete.</p> <p>This Red Phase ensures that the test is valid and will catch issues if the implementation is incorrect.</p> <pre><code>[TestMethod]\npublic void TestCalculateTotal_WhenNoItems_ShouldReturnZero()\n{\n    // Arrange\n    var cart = new ShoppingCart();\n\n    // Act\n    var result = cart.CalculateTotal();\n\n    // Assert\n    Assert.AreEqual(0, result); // Test fails initially, as CalculateTotal is not yet implemented\n}\n</code></pre>"},{"location":"unittest/#green-phase-passing-test","title":"Green Phase (Passing Test)","text":"<p>Implement the minimum amount of code required to make the test pass. Do only as much as needed to pass the test.</p> <p>This step is focused on meeting the requirements set by the test, not on optimizing or refining the code.</p> <pre><code>public class ShoppingCart\n{\n    public decimal CalculateTotal()\n    {\n        return 0; // Initial code to make the test pass\n    }\n}\n</code></pre>"},{"location":"unittest/#refactor-phase","title":"Refactor Phase","text":"<p>Once the test passes, refactor the code to improve its design, readability, and maintainability. This phase ensures that the code is clean, efficient, and follows best practices.</p> <p>The goal is to ensure the code adheres to best practices and is optimized while still passing the test.</p> <pre><code>public class ShoppingCart\n{\n    private List&lt;Item&gt; items = new List&lt;Item&gt;();\n\n    public decimal CalculateTotal()\n    {\n        return items.Sum(item =&gt; item.Price); // Refactored to handle multiple items\n    }\n}\n</code></pre>"},{"location":"unittest/#how-to-write-a-good-unit-test","title":"How to write a good unit test","text":""},{"location":"unittest/#1-use-clear-and-descriptive-names","title":"1. Use Clear and Descriptive Names","text":"<p>A test name should clearly describe the scenario being tested and the expected outcome. This helps anyone reading the code understand what the test checks without needing to dive into its details.</p> BAD<pre><code>[TestMethod]\npublic void Test1()\n{\n    var result = new ShoppingCart().CalculateTotal();\n    Assert.AreEqual(0, result);\n}\n</code></pre> GOOD<pre><code>[TestMethod]\npublic void CalculateTotal_WhenCartIsEmpty_ShouldReturnZero()\n{\n    // Arrange\n    var cart = new ShoppingCart();\n\n    // Act\n    var result = cart.CalculateTotal();\n\n    // Assert\n    Assert.AreEqual(0, result);\n}\n</code></pre>"},{"location":"unittest/#2-follow-the-aaa-pattern-arrange-act-assert","title":"2. Follow the AAA Pattern (Arrange, Act, Assert)","text":"<p>The AAA pattern helps structure the test into three distinct sections: Arrange, Act, and Assert.</p> <p>BAD<pre><code>[TestMethod]\npublic void TestCalculateTotal()\n{\n    Assert.AreEqual(30, new ShoppingCart { Items = { new Item(10), new Item(20) } }.CalculateTotal());\n}\n</code></pre> GOOD<pre><code>[TestMethod]\npublic void CalculateTotal_WithItems_ShouldReturnSumOfPrices()\n{\n    // Arrange\n    var cart = new ShoppingCart();\n    cart.AddItem(new Item { Price = 10 });\n    cart.AddItem(new Item { Price = 20 });\n\n    // Act\n    var result = cart.CalculateTotal();\n\n    // Assert\n    Assert.AreEqual(30, result);\n}\n</code></pre></p>"},{"location":"unittest/#3-test-one-scenario-at-a-time","title":"3. Test One Scenario At A Time","text":"<p>Each test should focus on one specific scenario or behavior. Testing multiple behaviors in a single test makes it harder to diagnose the issue when it fails.</p> BAD<pre><code>[TestMethod]\npublic void CalculateTotal_WithEmptyCartAndWithItems_ShouldReturnCorrectResult()\n{\n    var cart = new ShoppingCart();\n    Assert.AreEqual(0, cart.CalculateTotal());\n\n    cart.AddItem(new Item { Price = 15 });\n    Assert.AreEqual(15, cart.CalculateTotal());\n}\n</code></pre> GOOD<pre><code>[TestMethod]\npublic void CalculateTotal_WhenCartIsEmpty_ShouldReturnZero()\n{\n    var cart = new ShoppingCart();\n    var result = cart.CalculateTotal();\n    Assert.AreEqual(0, result);\n}\n\n[TestMethod]\npublic void CalculateTotal_WithSingleItem_ShouldReturnItemPrice()\n{\n    var cart = new ShoppingCart();\n    cart.AddItem(new Item { Price = 15 });\n    var result = cart.CalculateTotal();\n    Assert.AreEqual(15, result);\n}\n</code></pre>"},{"location":"unittest/#4-make-tests-independent","title":"4. Make Tests Independent","text":"<p>A unit test should be independant of other tests, therefore, each test should not rely on the state of another test. This ensures that each test can be run in isolation without affecting the results.</p> BAD<pre><code>[TestMethod]\npublic void CalculateTotal_WithMultipleCalls_ShouldReturnCumulativeTotal()\n{\n    var cart = new ShoppingCart();\n    cart.AddItem(new Item { Price = 10 });\n    Assert.AreEqual(10, cart.CalculateTotal());\n\n    cart.AddItem(new Item { Price = 20 });\n    Assert.AreEqual(30, cart.CalculateTotal());\n}\n</code></pre> GOOD<pre><code>[TestMethod]\npublic void CalculateTotal_AfterAddingMultipleItems_ShouldReturnSumOfPrices()\n{\n    var cart = new ShoppingCart();\n    cart.AddItem(new Item { Price = 10 });\n    cart.AddItem(new Item { Price = 20 });\n\n    Assert.AreEqual(30, cart.CalculateTotal());\n}\n</code></pre>"},{"location":"variables/","title":"Variables","text":""},{"location":"variables/#naming","title":"Naming","text":""},{"location":"variables/#name-constants-using-all_caps","title":"Name constants using ALL_CAPS","text":"<p>In C#, constants are named using ALL_CAPS with underscores separating words. <code>const</code> keyword is used for constant values, and <code>readonly</code> can be used for values that are set once and do not change after.</p> <pre><code>const string MY_CONSTANT = \"constant value\";\npublic static readonly string MY_GLOBAL_CONSTANT = \"another constant value\";\n</code></pre>"},{"location":"variables/#camelcase-for-non-constant-local-variable-names","title":"camelCase for non-constant local variable names","text":"<p>Local variables should follow camelCase to enhance readability and distinguish them from global or class-level variables.</p> <pre><code>string myVariable = \"variable value\";\n</code></pre>"},{"location":"variables/#pascalcase-for-public-properties-and-global-variables","title":"PascalCase for public properties and global variables","text":"<p>For global or public variables and properties, use PascalCase. This convention helps differentiate properties and fields from local variables.</p> <pre><code>public string MyGlobalVariable = \"global variable value\";\n</code></pre>"},{"location":"variables/#use-underscore-_-for-unused-variables-in-lambda-expressions","title":"Use underscore \"_\" for unused variables in lambda expressions","text":"<p>In C#, use _ to indicate variables that are required syntactically but will not be used. This is commonly seen in lambda expressions or event handlers.</p> <pre><code>public void PrintValues(Dictionary&lt;int, string&gt; map)\n{\n    foreach (var (_, value) in map)\n    {\n        Console.WriteLine(value);\n    }\n}\n</code></pre>"},{"location":"variables/#enums-vs-booleans","title":"Enums Vs Booleans","text":"<p>Enums should be used to represent a state when more than two options exist. Using multiple booleans to reflect different states can lead to confusion and unintended states. For example:</p> BAD<pre><code>bool isWalking = false;\nbool isRunning = false;\n</code></pre> <p>Instead, use an enum to represent the state clearly:</p> GOOD<pre><code>public enum MovementState\n{\n    Unknown = 0,\n    Walking = 1,\n    Running = 2\n}\n\nMovementState movementState = MovementState.Unknown;\n</code></pre> <p>Using an enum simplifies state management and future expansion (e.g., adding Idle, Swimming, etc.) while avoiding ambiguous states.</p>"},{"location":"variables/#name-spaces","title":"Name Spaces","text":"<p>Name Spaces should follow the project structure and should ALWAYS be in PascalCase.</p> <p>Name Spaces should always outline whewre the file is located in the project structure.</p> <p>A good convention would be <code>[Project].[Folder].[Feature]</code></p>"},{"location":"variables/#location","title":"Location","text":""},{"location":"variables/#local-variables-declare-variables-within-a-method-as-close-as-possible-to-where-theyre-used","title":"Local Variables: Declare variables within a method as close as possible to where they\u2019re used.","text":"<p>This minimizes the cognitive load for anyone reading the code, as they only need to consider relevant variables.</p>"},{"location":"variables/#class-level-variables-declare-at-the-top-of-the-class-in-the-order-constants-readonly-fields-private-variables-and-then-public-properties","title":"Class-Level Variables: Declare at the top of the class in the order: constants, readonly fields, private variables, and then public properties.","text":"<p>This keeps the structure organized and consistent.</p>"},{"location":"variables/#global-variables-avoid-unnecessary-global-variables-if-needed-declare-them-at-the-top-of-the-file-and-only-within-a-single-relevant-file-client-or-server","title":"Global Variables: Avoid unnecessary global variables. If needed, declare them at the top of the file and only within a single, relevant file (client or server).","text":"<p>This keeps the code organized and prevents variables from being scattered across multiple locations.</p>"}]}